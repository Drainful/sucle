(in-package :sandbox)

(defun isOpaque (id)
  (eq t (aref mc-blocks::opaquecubelooukup id)))

(defun lightnode (ans)
  (if ans
      (progn
	(let* ((ourpos (pop ans))
	       (i (first ourpos))
	       (j (second ourpos))
	       (k (third ourpos)))
	  (let ((courant (apply #'getlight ourpos)))
	    (unless (zerop courant)
	      (let ((current (1- courant)))
		(flet ((settest (x y z)
			 (unless (isOpaque (getblock x y z))
			   (setf (getlight x y z) current)
			   (pushnew (list x y z) ans :test #'equal))))
		  (let ((i- (getlight (- i 1) (+ j 0) (+ k 0)))
			(i+ (getlight (+ i 1) (+ j 0) (+ k 0)))
			(j- (getlight (+ i 0) (- j 1) (+ k 0)))
			(j+ (getlight (+ i 0) (+ j 1) (+ k 0)))
			(k- (getlight (+ i 0) (+ j 0) (- k 1)))
			(k+ (getlight (+ i 0) (+ j 0) (+ k 1))))
		    (if (< i- current)
			(settest (- i 1) (+ j 0) (+ k 0)))
		    (if (< i+ current)
			(settest (+ i 1) (+ j 0) (+ k 0)))
		    (if (< j- current)
			(settest (+ i 0) (- j 1) (+ k 0)))
		    (if (< j+ current)
			(settest (+ i 0) (+ j 1) (+ k 0)))
		    (if (< k- current)
			(settest (+ i 0) (+ j 0) (- k 1)))
		    (if (< k+ current)
			(settest (+ i 0) (+ j 0) (+ k 1)))))))))
	(lightnode ans))))

;;first we remove all the possible lights that could be affected by
;;the light we want to remove, then the surrounding lights fill in the
;;holes.
(defun delightnode (ans other)
  (if ans
      (progn
	(let* ((ourpos (pop ans))
	       (i (first ourpos))
	       (j (second ourpos))
	       (k (third ourpos)))
	  (let ((current (getlight i j k)))
	    (setf (getlight i j k) 0)
	    (flet ((settest (x y z)
		     (unless (isopaque (getblock x y z))
		       (pushnew (list x y z) ans :test #'equal)))
		   (lightprop (x y z)
		     (pushnew (list x y z) other :test #'equal)))
	      (let ((i- (getlight (- i 1) (+ j 0) (+ k 0)))
		    (i+ (getlight (+ i 1) (+ j 0) (+ k 0)))
		    (j- (getlight (+ i 0) (- j 1) (+ k 0)))
		    (j+ (getlight (+ i 0) (+ j 1) (+ k 0)))
		    (k- (getlight (+ i 0) (+ j 0) (- k 1)))
		    (k+ (getlight (+ i 0) (+ j 0) (+ k 1))))
		(unless (zerop i-)
		  (if (< i- current)
		      (settest (+ i -1) (+ j 0) (+ k 0))   
		      (lightprop (+ i -1) (+ j 0) (+ k 0))))
		(unless (zerop i+)
		  (if (< i+ current)
		      (settest (+ i 1) (+ j 0) (+ k 0))   
		      (lightprop (+ i 1) (+ j 0) (+ k 0))))
		(unless (zerop j-)
		  (if (< j- current)
		      (settest (+ i 0) (+ j -1) (+ k 0))   
		      (lightprop (+ i 0) (+ j -1) (+ k 0))))
		(unless (zerop j+)
		  (if (< j+ current)
		      (settest (+ i 0) (+ j 1) (+ k 0))   
		      (lightprop (+ i 0) (+ j 1) (+ k 0))))
		(unless (zerop k-)
		  (if (< k- current)
		      (settest (+ i 0) (+ j 0) (+ k -1))   
		      (lightprop (+ i 0) (+ j 0) (+ k -1))))
		(unless (zerop k+)
		  (if (< k+ current)
		      (settest (+ i 0) (+ j 0) (+ k 1))   
		      (lightprop (+ i 0) (+ j 0) (+ k 1))))))))
	(delightnode ans other))
      (if other
	  (lightnode other))))

(defun skylightnode (ans)
  (if ans
      (progn
	(let* ((ourpos (pop ans))
	       (i (first ourpos))
	       (j (second ourpos))
	       (k (third ourpos)))
	  (let* ((current (apply #'skygetlight ourpos))
		 (1-current (1- current)))
	    (flet ((settest (x y z)
		     (unless (isOpaque (getblock x y z))
		       (setf (skygetlight x y z) (1- current))
		       (pushnew (list x y z) ans :test #'equal)))
		   (wowtest (x y z)
		     (unless (or (isOpaque (getblock x y z))
				 (> 0 y))
		       (setf (skygetlight x y z) 15)
		       (pushnew (list x y z) ans :test #'equal))))
	      (let ((i- (skygetlight (- i 1) (+ j 0) (+ k 0)))
		    (i+ (skygetlight (+ i 1) (+ j 0) (+ k 0)))
		    (j- (skygetlight (+ i 0) (- j 1) (+ k 0)))
		    (j+ (skygetlight (+ i 0) (+ j 1) (+ k 0)))
		    (k- (skygetlight (+ i 0) (+ j 0) (- k 1)))
		    (k+ (skygetlight (+ i 0) (+ j 0) (+ k 1))))
		(if (< i- 1-current)
		    (settest (- i 1) (+ j 0) (+ k 0)))
		(if (< i+ 1-current)
		    (settest (+ i 1) (+ j 0) (+ k 0)))
		(if (= 15 current)
		    (wowtest (+ i 0) (- j 1) (+ k 0))
		    (if (< j- 1-current)
			(settest (+ i 0) (- j 1) (+ k 0))))
		(if (< j+ 1-current)
		    (settest (+ i 0) (+ j 1) (+ k 0)))
		(if (< k- 1-current)
		    (settest (+ i 0) (+ j 0) (- k 1)))
		(if (< k+ 1-current)
		    (settest (+ i 0) (+ j 0) (+ k 1)))))))
	(skylightnode ans))))

;;first we remove all the possible lights that could be affected by
;;the light we want to remove, then the surrounding lights fill in the
;;holes.
(defun skydelightnode (ans other)
  (if ans
      (progn
	(let* ((ourpos (pop ans))
	       (i (first ourpos))
	       (j (second ourpos))
	       (k (third ourpos)))
	  (let ((current (skygetlight i j k)))
	    (setf (skygetlight i j k) 0)
	    (flet ((settest (x y z)
		     (unless (or (isopaque (getblock x y z))
				 (< y 0))
		       (pushnew (list x y z) ans :test #'equal)))
		   (lightprop (x y z)
		     (pushnew (list x y z) other :test #'equal)))
	      (let ((i- (skygetlight (- i 1) (+ j 0) (+ k 0)))
		    (i+ (skygetlight (+ i 1) (+ j 0) (+ k 0)))
		    (j- (skygetlight (+ i 0) (- j 1) (+ k 0)))
		    (j+ (skygetlight (+ i 0) (+ j 1) (+ k 0)))
		    (k- (skygetlight (+ i 0) (+ j 0) (- k 1)))
		    (k+ (skygetlight (+ i 0) (+ j 0) (+ k 1))))
		(unless (zerop i-)
		  (if (< i- current)
		      (settest (+ i -1) (+ j 0) (+ k 0))   
		      (lightprop (+ i -1) (+ j 0) (+ k 0))))
		(unless (zerop i+)
		  (if (< i+ current)
		      (settest (+ i 1) (+ j 0) (+ k 0))   
		      (lightprop (+ i 1) (+ j 0) (+ k 0))))
		(unless (zerop j-)
		  (if (< j- current)
		      (settest (+ i 0) (+ j -1) (+ k 0))   
		      (lightprop (+ i 0) (+ j -1) (+ k 0))))
		(if (= 15 current)
		    (settest (+ i 0) (+ j -1) (+ k 0)))
		(unless (zerop j+)
		  (if (< j+ current)
		      (settest (+ i 0) (+ j 1) (+ k 0))   
		      (lightprop (+ i 0) (+ j 1) (+ k 0))))
		(unless (zerop k-)
		  (if (< k- current)
		      (settest (+ i 0) (+ j 0) (+ k -1))   
		      (lightprop (+ i 0) (+ j 0) (+ k -1))))
		(unless (zerop k+)
		  (if (< k+ current)
		      (settest (+ i 0) (+ j 0) (+ k 1))   
		      (lightprop (+ i 0) (+ j 0) (+ k 1))))))))
	(skydelightnode ans other))
      (if other
	  (skylightnode other))))
