
(progno
 (defun read-yolo (text)
   (let ((state :nope)
	 (text (cons " " (split-sequence:split-sequence #\newline text)))
	 acc)
     (dolist (item text)
       (if (equalp item " ")
	   (setf state :eat-next)
	   (progn
	     (when (eq state :eat-next)
	       (push (split-sequence:split-sequence #\tab item)
		     acc))
	     (setf state :full))))
     (nreverse acc)))

 (defun print-out (list)
   (let ((*print-case* :downcase))
     (dolist (item list)
       (let ((a (first item))
	     (b (second item)))
	 (princ "(")
	 (princ b)
	 (princ " ")
	 (let ((a2 (pase-tip a)))
	   (let* ((pointers (end-pointers? a2))
		  (type (get-item
			 (if (zerop pointers)
			     a2
			     (nbutlast a2)))))
	     (let ((acc type))
	       (dotimes (i pointers)
		 (setf acc (if t :pointer (list :pointer acc))))
	       (prin1 acc))))
	 (princ ")"))
       (terpri))))

 (defun pase-tip (string)
   (let ((values (split-sequence:split-sequence #\space string)))
     (setf values (delete-if
		   (lambda (x)
		     (or (equal x "")
			 (equal x "const")
			 (equal x "attribute_deprecated"))) values))
     values))

 (defun end-pointers? (list)
   (let ((item (car (last list))))
     (if (eql #\* (aref item 0))
	 (array-total-size item)
	 0)))

 (defparameter *c-types* (make-hash-table :test 'equal))
 (defun add-item (item keyword)
   (let ((items (split-sequence:split-sequence #\space item)))
     (setf (gethash items *c-types*) keyword)))
 (defun get-item (item)
   (if (equal "enum" (car item))
       :int
       (or (gethash item *c-types*)
	   (intern (car item)))))


 (mapcar #'(lambda (x) (add-item (first x)
				 (second x)))
	 (quote (("char" :char)
		 ("unsigned char" :unsigned-char)
		 ("short" :short)
		 ("unsigned short" :unsigned-short)
		 ("int" :int)
		 ("unsigned int" :uint)
		 ("long" :long)
		 ("unsigned long" :unsigned-long)
		 ("long long" :long-long)
		 ("unsigned long long" :unsigned-long-long)
		 ("float" :float)
		 ("double" :double)
		 ("int8_t" :int8)
		 ("int16_t" :int16)
		 ("int32_t" :int32)
		 ("int64_t" :int64)
		 ("uint8_t" :uint8)
		 ("uint16_t" :uint16)
		 ("uint32_t" :uint32)
		 ("uint64_t" :uint64)
		 ("void" :void)
		 ("unsigned" :unsigned-int)))))

(progno
 (defun decode-audio-file (path sample-rate data size)
   (av-register-all)
   (with-foreign-object (format-pointer :pointer)
     (setf (mem-ref format-pointer :pointer) (avformat-alloc-context))
     (unless
	 (zerop
	  (with-foreign-string (cpath path)
	    (avformat-open-input
	     format-pointer
	     cpath
	     (cffi:null-pointer)
	     (cffi:null-pointer))))
       (print "could not open file")
       (return-from decode-audio-file -1))
     (when (< (avformat-find-stream-info
	       (mem-ref format-pointer :pointer)
	       (cffi:null-pointer))
	      0)
       (print "could not retrieve stream info from file")
       (return-from decode-audio-file -1))
     (let ((avformat (mem-ref format-pointer :pointer)))
       (let ((stream-index -1))
	 (block break
	   (with-foreign-slots ((nb_streams streams) avformat (:struct |AVFormatContext|))	   
	     (dotimes (i nb_streams)
	       (when (= 1 (with-foreign-slots ((codec) streams |AVStream|)
			    (with-foreign-slots ((codec_type) codec |AVCodecContext|)
			      codec_type)))
		 (setf stream-index i)
		 (return-from break)))))
	 (when (= -1 stream-index)
	   (print "could not retrieve audio stream from file")
	   (return-from decode-audio-file -1))
	 (let ((stream-pointer (with-foreign-slots ((streams)))))))
       (av-frame-free frame-pointer)
       (swr-free swr-pointer)
       (avcodec-close codec)
       (avformat-free-context avformat)))))
